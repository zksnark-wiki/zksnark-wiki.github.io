{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Welcome to zkSNARK wiki","text":""},{"location":"contri/","title":"zkSNARK Wiki: Contribution Guide","text":""},{"location":"contri/#getting-started","title":"Getting Started","text":"<ol> <li>Clone the repository: <code>git clone https://github.com/zksnark-wiki/zksnark-wiki.github.io.git</code></li> <li>Install MkDocs: <code>pip install mkdocs</code></li> <li>Install the Material for MkDocs theme: <code>pip install mkdocs-material</code></li> </ol>"},{"location":"contri/#workflow","title":"Workflow","text":"<ol> <li>Remember to pull and merge.</li> <li>Create a new Markdown (<code>.md</code>) file in the <code>docs</code> directory and write your content.</li> <li>Integrate your new page into the navigation by editing <code>mkdocs.yml</code></li> <li>Preview your changes locally with <code>mkdocs serve</code>.</li> <li>Commit your updates to Git:<ul> <li><code>git add .</code></li> <li><code>git commit -m \"Add new post about X\"</code></li> <li><code>git push</code></li> </ul> </li> <li>Deploy the site to GitHub Pages: <code>mkdocs gh-deploy --force</code></li> </ol>"},{"location":"commitment/","title":"Commitment","text":"<p>Commitment</p>"},{"location":"commitment/pedersen/","title":"Pedersen Commitment","text":"<p>Pedersen Commitment can be derived from Schnorr's \\(\\Sigma\\)-protocol for the Discrete Logarithm Relation.</p> <p>At the start of the protocol, the prover generates two generators of the group \\(\\mathbb G\\), we denote them with \\(g, h\\). To commit to \\(m\\in\\mathbb Z_q\\), the prover chooses \\(z\\in\\mathbb Z_q\\) randomly and sends \\(C_m=g^m\\cdot h^z\\) to the verifier. To open it, the prover just sends \\((m,z)\\) to the verifier, and verifier checks that \\(C_m\\stackrel{?}{=}g^m\\cdot h^z\\).</p> <p>The correctness, computational binding and perfect hiding is directly guarenteed by the properties of \\(\\Sigma\\)-protocol and Damg\u00e5rd's construction.</p> <p>Moreover, Pedersen Commitment is additively homomorphic.</p>"},{"location":"commitment/pedersen/#establishing-product-relationship","title":"Establishing Product Relationship","text":""},{"location":"commitment/pedersen/#pedersen-vector-commitment","title":"Pedersen Vector Commitment","text":"<p>\\(C_m=g_0^{m_0}g_1^{m_1}\\cdots g_{n-1}^{m_{n-1}}h^{z}\\)</p>"},{"location":"distributed/","title":"Distributed Zero-Knowledge Proof","text":""},{"location":"distributed/devirgo/","title":"DeVirgo","text":""},{"location":"distributed/dizk/","title":"DIZK","text":""},{"location":"distributed/pianist/","title":"Pianist","text":"<p>The Pianist protocol is a distributed zkSNARK system designed to enable multiple machines to collaboratively generate a single, succinct proof. The protocol's core innovation lies in the elegant combination of a bivariate Plonk constraint system and a distributively computable KZG polynomial commitment scheme. This allows for the parallelization of the computationally intensive proving process, leading to a linear increase in prover speed as more machines are added. A key architectural benefit is that this scalability is achieved while maintaining a constant, asymptotically optimal communication overhead, proof size, and verifier time, regardless of the complexity of the underlying computation or the number of transactions being processed. \u00a0 </p>"},{"location":"pcs/","title":"Polynomial Commitment Scheme","text":""},{"location":"pcs/#what-are-polynomial-commitment-schemes-pcs","title":"What Are Polynomial Commitment Schemes (PCS)?","text":"<p>Imagine you're a magician who wants to prove you know a secret polynomial\u2014a long, complicated mathematical equation\u2014without revealing what it is. You want to convince someone that your polynomial, when evaluated at a specific number, equals a certain value. But there's a catch: you can only send them a tiny, fixed-size proof.</p> <p>This is the essence of a Polynomial Commitment Scheme (PCS). It's a cryptographic primitive that lets a prover \"commit\" to a polynomial in a way that is both succinct and secure.</p> <p>In simpler terms, a PCS is a powerful tool with three main steps:</p> <ol> <li>Commit: You take a polynomial, \\(P(x)\\), and generate a short, cryptographic representation of it. This is the commitment. Think of it as a fingerprint for the polynomial. You can share this fingerprint with anyone without revealing the polynomial's coefficients.</li> <li>Open: Later, someone gives you a challenge: \"What's the value of your polynomial at point \\(z\\)?\" You respond with the value, \\(v = P(z)\\), and a very small proof \\(\\pi\\).</li> <li>Verify: The verifier uses your original commitment, the point \\(z\\), the claimed value \\(v\\), and your proof \\(\\pi\\) to check if everything is correct. The amazing part? They can do this in a fraction of a second, without ever seeing the polynomial itself.</li> </ol>"},{"location":"pcs/#what-makes-a-good-pcs","title":"What Makes a Good PCS?","text":"<p>Not all schemes are created equal. A high-quality PCS should have these properties:</p> <ul> <li>Succinctness: The commitment and the proof must be extremely small, regardless of how large the polynomial is. This is what makes it practical.</li> <li>Binding: Once you commit to a polynomial, you can't change your mind. It's impossible to \"open\" the commitment to a different polynomial.</li> <li>Hiding: The commitment should not reveal any information about the polynomial's coefficients.</li> </ul>"},{"location":"pcs/#univariant-and-multilinear","title":"Univariant and Multilinear","text":"<p>Polynomials come in different forms, and PCS are often classified by the type they are designed for. For most use cases, we need either a univariant PCS or a multilinear PCS.</p> <ul> <li> <p>Univariant Polynomials: These are the polynomials involving only a single variable, like \\(P(x) = 5x^3 + 2x - 1\\). Many popular schemes, including KZG, are designed for these single-variable polynomials.</p> </li> <li> <p>Multilinear Polynomials: A multilinear polynomial is a special type of polynomial with multiple variables, where each variable appears with a power of at most 1. They are often used to represent logical circuits or computations. Schemes like the FRI are designed to handle these types of polynomials efficiently.</p> </li> </ul>"},{"location":"pcs/#popular-pcs-examples","title":"Popular PCS Examples","text":"<p>There are a few widely-used PCS, each with its own trade-offs. The main difference often comes down to their efficiency and whether they need a trusted setup. A trusted setup is a one-time cryptographic event that generates public parameters. If this event is compromised, the entire system's security can be at risk.</p>"},{"location":"pcs/#kzg-kate-zaverucha-goldberg-commitments","title":"KZG (Kate-Zaverucha-Goldberg) Commitments","text":"<ul> <li>Pros: They are incredibly efficient. Both the proof size and the verification time are constant, meaning they stay the same no matter how large the polynomial is.</li> <li>Cons: They require a trusted setup. This has led to high-profile ceremonies like the one for the Zcash network, where many people participate to ensure no single party holds the secret.</li> </ul>"},{"location":"pcs/#ipa-inner-product-argument-commitments","title":"IPA (Inner Product Argument) Commitments","text":"<ul> <li>Pros: They do not require a trusted setup, which is a massive security benefit. They rely on more common cryptographic assumptions.</li> <li>Cons: They are less efficient than KZG. The proof size and verification time grow logarithmically with the size of the polynomial, which is still very fast but not constant.</li> </ul>"},{"location":"pcs/#comparing","title":"Comparing","text":"Scheme Name Commitment Size Proof Size Verification Time Prover Time Trusted Setup Security Assumption Core Technique Advantages Disadvantages KZG(U)<sup>1</sup> \\(O(1)\\) \\(O(1)\\) \\(O(1)\\) \\(O(n)\\) Required CDH on Pairing-friendly curves Bilinear Pairings Small proofs, fast verification Relies on a trusted setup FRI <sup>3</sup> \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(n \\log n)\\) Not required Collision resistance of hash functions Iterative low-degree testing Fully transparent, post-quantum secure Relatively large proofs, high verification cost IPA <sup>4</sup> \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(n \\log n)\\) Not required Discrete Logarithm (DL) problem Inner Product Argument, Fiat-Shamir No trusted setup, logarithmic proof size Can be slower than KZG for large n Bulletproofs <sup>2</sup> <sup>9</sup> \\(O(1)\\) \\(O(\\log n)\\) \\(O(n)\\) \\(O(n)\\) Not required Discrete Logarithm (DL) problem Inner Product Argument No trusted setup, small proof size Slower verification than KZG Dory \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(n)\\) Not required Hyrax <sup>5</sup> \\(O(\\log n)\\) \\(O(\\log^2 n)\\) \\(O(n \\log n)\\) Not required DL and Strong RSA assumptions Vector commitments, inner product arguments No trusted setup, fast verification Relies on specific assumptions Brakedown <sup>6</sup> \\(O(1)\\) \\(O(n)\\) \\(O(n \\log n)\\) Not required DL and higher-order DL assumptions Batching techniques Constant-size proofs without trusted setup Linear verification time Gemini <sup>7</sup> \\(O(1)\\) \\(O(\\log n)\\) \\(O(n \\log n)\\) Not required DL and higher-order DL assumptions Polynomial combination for batching Combines KZG and FRI advantages Relatively complex protocol Virgo <sup>8</sup> \\(O(\\log^2 n)\\) \\(O(\\log^2 n)\\) \\(O(n \\log n)\\) Not required Polylogarithmic inner product argument Vector polynomial delegation No trusted setup, post-quantum secure Proof and verification time are not constant"},{"location":"pcs/#key-metrics-explained","title":"Key Metrics Explained","text":"<ul> <li>U/M: For univariant polynomials or multilinear polynomials.</li> <li>Proof Size: A smaller proof size reduces network transmission overhead, which is crucial in scenarios like blockchains. KZG and Dark/Brakdown achieve the ideal constant-size proofs, while FRI and Virgo achieve logarithmic or polylogarithmic growth, which is significantly better than linear.</li> <li>Verification Time: This is a critical metric for on-chain verification. KZG has the fastest, constant-time verification. Bulletproofs, FRI, and Gemini also have very fast logarithmic verification times, while Dark and Virgo are slightly slower.</li> <li>Prover Time: The prover time for all major schemes is quasi-linear, at \\(O(n \\log n)\\), so there is little significant difference in this metric.</li> <li>Trusted Setup: Whether a scheme requires a trusted setup is a key differentiator. KZG requires a one-time, universal trusted setup, and if this process is compromised, the entire system's security can be at risk. Schemes like FRI, Bulletproofs, Hyrax, and Virgo are transparent and do not require a trusted setup, giving them a natural security advantage.</li> <li>Security Assumptions: Different schemes rely on different mathematical problems. KZG depends on the difficulty of problems on bilinear pairings. FRI and Virgo primarily rely on the collision resistance of hash functions, making them generally considered post-quantum secure.</li> </ul>"},{"location":"pcs/#references","title":"References","text":"<ol> <li> <p>Kate, A., Zaverucha, G., &amp; Goldberg, I. (2010). Constant-size commitments to polynomials and their applications.\u00a0\u21a9</p> </li> <li> <p>B\u00fcnz, M., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., &amp; Maxwell, G. (2018). Bulletproofs: Short proofs for confidential transactions and more.\u00a0\u21a9</p> </li> <li> <p>Ben-Sasson, E., Bentov, I., Horesh, Y., &amp; Riabzev, M. (2018). Scalable, transparent, and post-quantum secure computational integrity.\u00a0\u21a9</p> </li> <li> <p>Groth, J. (2016). On the size of pairing-based non-interactive arguments.\u00a0\u21a9</p> </li> <li> <p>Wahby, R. S., Tzialla, I., Shelat, A., Thaler, J., &amp; Walfish, M. (2017). Doubly-efficient zkSNARKs without trusted setup.\u00a0\u21a9</p> </li> <li> <p>Golovnev, A., Lee, J., Setty, S., Thaler, J. &amp; Wahby, R. S. (2021). Brakedown: Linear-time and field-agnostic SNARKs for R1CS.\u00a0\u21a9</p> </li> <li> <p>Bootle, J., Chiesa, A., Hu, Y., &amp; Orr\u00f9, M. (2022). Gemini: Elastic SNARKs for Diverse Environments.\u00a0\u21a9</p> </li> <li> <p>Zhang, J., Xie, T., Zhang, Y., &amp; Song, D. (2020). Virgo: Transparent polynomial delegation and its applications to zero-knowledge proof.\u00a0\u21a9</p> </li> <li> <p>Boneh, D., Drake, J., Fisch, B., &amp; Gabizon, A. (2021). Halo Infinite: Recursive zk-SNARKs from any Additive Polynomial Commitment Scheme.\u00a0\u21a9</p> </li> </ol>"},{"location":"pcs/ipa/","title":"IPA Commitment","text":""},{"location":"pcs/kzg/","title":"KZG Commitment","text":""},{"location":"pcs/kzg/#preliminaries","title":"Preliminaries","text":"<ul> <li>DLP (Discrete Logarithm Problem), DDH (Decision Diffie-Hellman assumption), CDH (Computational Diffie-Hellman assumption).</li> <li>Pairing and pairing-friendly groups.</li> <li>Schwarz-Zippel Lemma.</li> </ul>"},{"location":"pcs/kzg/#kzg-commitment-for-univariant-polynomials","title":"KZG Commitment for Univariant Polynomials","text":"<p>The process of a KZG commitment can be broken down into four distinct phases:</p>"},{"location":"pcs/kzg/#1-trusted-setup","title":"1. Trusted Setup","text":"<p>This is a one-time ceremony that generates the public parameters (the SRS) which are then used by everyone (both the prover and the verifier). </p> <p>The SRS consists of elements on a pairing-friendly group \\(\\mathbb G\\), that is, \\((g,g^{\\tau},g^{\\tau^2},...,g^{\\tau^d})\\) where \\(d\\) is the maximum degree of any polynomial to be committed to, and \\(g\\) is a generator of the group. The value \\(\\tau\\) is chosen from \\(\\{0,1,...,|\\mathbb G|-1\\}\\) at random, and as a \"toxic waste\", it should be discarded once the SRS has been generated. So \\(\\tau\\) can't be known by anyone.</p>"},{"location":"pcs/kzg/#2-commitment","title":"2. Commitment","text":"<p>The prover, who has a polynomial \\(q(x)\\) of degree at most \\(d\\), wants to commit to it. He computes the commitment \\(C\\) by \"evaluating\" \\(g^{q(\\tau)}\\). Since he doesn't know \\(\\tau\\), he uses the public SRS:</p> \\[C = g^{q(\\tau)} = g^{\\sum_{i=0}^d c_i \\tau^i} = \\prod_{i=0}^d (g^{\\tau^i})^{c_i}\\] <p>The result, \\(C\\), is an single element of \\(\\mathbb G\\)\u2014a constant-sized commitment regardless of the polynomial's degree. The prover sends this commitment to the verifier. Because of the cryptographic properties, the commitment is binding: once the prover has generated \\(C\\), they cannot \"open\" it to a different polynomial.</p>"},{"location":"pcs/kzg/#3-proving-an-evaluation","title":"3. Proving an Evaluation","text":"<p>Now, the prover wants to convince the verifier that the polynomial \\(q(X)\\) evaluates to a specific value \\(v\\) at a point \\(z\\). That is, they want to prove \\(q(z) = v\\).</p> <p>The prover constructs a new polynomial, the \"quotient polynomial\" \\(w(X)\\):</p> \\[w(X) = \\frac{q(X) - v}{X - z}\\] <p>The key insight here is from the Remainder Theorem in algebra: \\(q(z) - v = 0\\) if and only if \\((X-z)\\) is a factor of \\(q(X) - v\\). If the evaluation is correct (\\(q(z) = v\\)), then \\(w(z)\\) will be a valid polynomial. The prover then computes a commitment to this quotient polynomial, which will serve as the proof \\(\\pi\\):</p> \\[\\pi = g^{w(\\tau)}\\] <p>The prover sends the claimed evaluation \\((z, v)\\) and the proof \\(\\pi\\) to the verifier.</p>"},{"location":"pcs/kzg/#4-verification","title":"4. Verification","text":"<p>The verifier receives the commitment \\(C\\), the claimed evaluation \\((z, v)\\), and the proof \\(\\pi\\). He wants to check if the equation \\(q(X)-v=(X-z)w(X)\\) holds. Due to the Schwartz-Zippel Lemma, he only needs to check whether it holds at a random point, that is, \\(\\tau\\). As \\(\\tau\\) is unknown to the prover, it's safe to take it as a random number.</p> <p>So now the verifier wants to check \\(q(\\tau)-v=(\\tau-z)w(\\tau)\\). Using the bilinear pairing, they can check this equality in the exponent without ever knowing \\(\\tau\\).</p> <p>The verifier checks if the following pairing equation holds:</p> \\[e(C / g^{v}, g) = e(g^{\\tau - z}, \\pi)\\] <p>The equation holds if and only if \\(q(\\tau) - v = (\\tau - z)w(\\tau)\\), which, because of the Schwartz-Zippel Lemma, proves with a high probability that \\(q(X) - v = (X-z)w(X)\\) and therefore that \\(q(z) = v\\).</p>"},{"location":"pcs/kzg/#analysis","title":"Analysis","text":"<p>The commitment size and the proof size are \\(O(1)\\) as the they contain only one group element respectively. It takes the prover \\(O(d)\\) time to compute the commitment \\(C\\) and the proof \\(\\pi=g^{\\frac{q(X)-v}{X-z}}\\). The verifier time is \\(O(1)\\).</p>"},{"location":"pcs/kzg/#for-multilinear-polynomials","title":"For Multilinear Polynomials","text":"<p>It's based on the following fact.</p> <p>Fact (Papamanthou, Shi, and Tamassia [PST13]). For any fixed \\(z = (z_1, \\dots, z_\\ell) \\in \\mathbb{F}_p^\\ell\\) and any multilinear polynomial \\(q\\), \\(q(z) = v\\) if and only if there is a unique set of \\(\\ell\\) multilinear polynomials \\(w_1, \\dots, w_\\ell\\) such that $$ q(X) - v = \\sum_{i=1}^\\ell (X_i - z_i)w_i(X). $$</p>"},{"location":"pcs/kzg/#1-proving-an-evaluation","title":"1. Proving an Evaluation","text":"<p>Suppose a prover wants to prove that a multilinear polynomial \\(q(X)\\) evaluates to a specific value \\(v\\) at a point \\(z = (z_1, \\dots, z_\\ell)\\).</p> <p>The prover's task is to provide proof for the relationship in the above fact. The most straightforward approach is for the prover to compute a commitment for each of the \\(\\ell\\) quotient polynomials. The proof, \\(\\pi\\), would be a tuple of these commitments:</p> \\[\\pi = (g^{w_1(\\tau)}, g^{w_2(\\tau)}, \\dots, g^{w_\\ell(\\tau)})\\] <p>The prover sends the claimed evaluation \\((z, v)\\) along with the proof \\(\\pi\\) to the verifier.</p>"},{"location":"pcs/kzg/#2-verification","title":"2. Verification","text":"<p>The verifier receives the commitment \\(C = g^{q(\\tau)}\\), the claimed evaluation \\((z, v)\\), and the proof \\(\\pi\\). The verifier's goal is to check if the polynomial identity holds in the exponent. This can be verified with \\(\\ell\\) separate pairing checks:</p> \\[e(C/g^v, g) = \\prod_{i=1}^\\ell e(g^{w_i(\\tau)}, g^{\\tau_i-z_i})\\] <p>This equation holds if and only if the original polynomial identity is correct, which proves with high probability that \\(q(z) = v\\). While this is a correct verification method, it is important to note that the verifier's time scales with the number of variables, \\(\\ell\\), which can be a limiting factor.</p>"},{"location":"pcs/kzg/#analysis_1","title":"Analysis","text":"<p>In this extended scheme for multilinear polynomials, the commitment size remains constant at \\(O(1)\\) (one group element). However, the proof size is \\(O(\\ell)\\) because the proof consists of commitments to each of the \\(\\ell\\) quotient polynomials. Consequently, the verifier's time is also \\(O(\\ell)\\), as it must perform a pairing check for each polynomial. As for the prover time, [ZGK+18] shows that the prover can compute \\(w_1,...,w_{\\ell}\\) and evaluate \\(g^{w_1(r)},...,g^{w_{\\ell}(r)}\\) with \\(O(2^{\\ell})\\) time.</p>"},{"location":"pcs/kzg/#references","title":"References","text":"<ol> <li> <p>[PST13] Papamanthou, C., Shi, E., &amp; Tamassia, R. (2013). Signatures of Correct Computation.\u00a0\u21a9</p> </li> <li> <p>[Tha23] Thaler, J. (2023). Proofs, Arguments, and Zero-Knowledge.  \u21a9</p> </li> <li> <p>[ZGK+18] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., &amp; Papamanthou, C. (2018). vRAM: Faster Verifiable RAM With Program-Independent Preprocessing.\u00a0\u21a9</p> </li> </ol>"}]}