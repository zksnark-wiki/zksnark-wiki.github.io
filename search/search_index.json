{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Welcome to zkSNARK wiki","text":""},{"location":"contri/","title":"zkSNARK Wiki: Contribution Guide","text":""},{"location":"contri/#getting-started","title":"Getting Started","text":"<ol> <li>Clone the repository: <code>git clone https://github.com/zksnark-wiki/zksnark-wiki.github.io.git</code></li> <li>Install MkDocs: <code>pip install mkdocs</code></li> <li>Install the Material for MkDocs theme: <code>pip install mkdocs-material</code></li> </ol>"},{"location":"contri/#workflow","title":"Workflow","text":"<ol> <li>Remember to pull and merge.</li> <li>Create a new Markdown (<code>.md</code>) file in the <code>docs</code> directory and write your content.</li> <li>Integrate your new page into the navigation by editing <code>mkdocs.yml</code></li> <li>Preview your changes locally with <code>mkdocs serve</code>.</li> <li>Commit your updates to Git:<ul> <li><code>git add .</code></li> <li><code>git commit -m \"Add new post about X\"</code></li> <li><code>git push</code></li> </ul> </li> <li>Deploy the site to GitHub Pages: <code>mkdocs gh-deploy --force</code></li> </ol>"},{"location":"commitment/","title":"Commitment","text":"<p>Commitment</p>"},{"location":"commitment/pedersen/","title":"Pedersen Commitment","text":"<p>Pedersen Commitment can be derived from Schnorr's \\(\\Sigma\\)-protocol for the Discrete Logarithm Relation.</p> <p>At the start of the protocol, the prover generates two generators of the group \\(\\mathbb G\\), we denote them with \\(g, h\\). To commit to \\(m\\in\\mathbb Z_q\\), the prover chooses \\(z\\in\\mathbb Z_q\\) randomly and sends \\(C_m=g^m\\cdot h^z\\) to the verifier. To open it, the prover just sends \\((m,z)\\) to the verifier, and verifier checks that \\(C_m\\stackrel{?}{=}g^m\\cdot h^z\\).</p> <p>The correctness, computational binding and perfect hiding is directly guarenteed by the properties of \\(\\Sigma\\)-protocol and Damg\u00e5rd's construction.</p> <p>Moreover, Pedersen Commitment is additively homomorphic.</p>"},{"location":"commitment/pedersen/#establishing-product-relationship","title":"Establishing Product Relationship","text":""},{"location":"commitment/pedersen/#pedersen-vector-commitment","title":"Pedersen Vector Commitment","text":"<p>\\(C_m=g_0^{m_0}g_1^{m_1}\\cdots g_{n-1}^{m_{n-1}}h^{z}\\)</p>"},{"location":"pcs/","title":"Polynomial Commitment Scheme","text":""},{"location":"pcs/#what-are-polynomial-commitment-schemes-pcs","title":"What Are Polynomial Commitment Schemes (PCS)?","text":"<p>Imagine you're a magician who wants to prove you know a secret polynomial\u2014a long, complicated mathematical equation\u2014without revealing what it is. You want to convince someone that your polynomial, when evaluated at a specific number, equals a certain value. But there's a catch: you can only send them a tiny, fixed-size proof.</p> <p>This is the essence of a Polynomial Commitment Scheme (PCS). It's a cryptographic primitive that lets a prover \"commit\" to a polynomial in a way that is both succinct and secure.</p> <p>In simpler terms, a PCS is a powerful tool with three main steps:</p> <ol> <li>Commit: You take a polynomial, \\(P(x)\\), and generate a short, cryptographic representation of it. This is the commitment. Think of it as a fingerprint for the polynomial. You can share this fingerprint with anyone without revealing the polynomial's coefficients.</li> <li>Open: Later, someone gives you a challenge: \"What's the value of your polynomial at point \\(z\\)?\" You respond with the value, \\(v = P(z)\\), and a very small proof \\(\\pi\\).</li> <li>Verify: The verifier uses your original commitment, the point \\(z\\), the claimed value \\(v\\), and your proof \\(\\pi\\) to check if everything is correct. The amazing part? They can do this in a fraction of a second, without ever seeing the polynomial itself.</li> </ol>"},{"location":"pcs/#what-makes-a-good-pcs","title":"What Makes a Good PCS?","text":"<p>Not all schemes are created equal. A high-quality PCS should have these properties:</p> <ul> <li>Succinctness: The commitment and the proof must be extremely small, regardless of how large the polynomial is. This is what makes it practical.</li> <li>Binding: Once you commit to a polynomial, you can't change your mind. It's impossible to \"open\" the commitment to a different polynomial.</li> <li>Hiding: The commitment should not reveal any information about the polynomial's coefficients.</li> </ul>"},{"location":"pcs/#univariant-and-multilinear","title":"Univariant and Multilinear","text":"<p>Polynomials come in different forms, and PCS are often classified by the type they are designed for. For most use cases, we need either a univariant PCS or a multilinear PCS.</p> <ul> <li> <p>Univariant Polynomials: These are the polynomials involving only a single variable, like \\(P(x) = 5x^3 + 2x - 1\\). Many popular schemes, including KZG, are designed for these single-variable polynomials.</p> </li> <li> <p>Multilinear Polynomials: A multilinear polynomial is a special type of polynomial with multiple variables, where each variable appears with a power of at most 1. They are often used to represent logical circuits or computations. Schemes like the FRI are designed to handle these types of polynomials efficiently.</p> </li> </ul>"},{"location":"pcs/#popular-pcs-examples","title":"Popular PCS Examples","text":"<p>There are a few widely-used PCS, each with its own trade-offs. The main difference often comes down to their efficiency and whether they need a trusted setup. A trusted setup is a one-time cryptographic event that generates public parameters. If this event is compromised, the entire system's security can be at risk.</p>"},{"location":"pcs/#kzg-kate-zaverucha-goldberg-commitments","title":"KZG (Kate-Zaverucha-Goldberg) Commitments","text":"<ul> <li>Pros: They are incredibly efficient. Both the proof size and the verification time are constant, meaning they stay the same no matter how large the polynomial is.</li> <li>Cons: They require a trusted setup. This has led to high-profile ceremonies like the one for the Zcash network, where many people participate to ensure no single party holds the secret.</li> </ul>"},{"location":"pcs/#ipa-inner-product-argument-commitments","title":"IPA (Inner Product Argument) Commitments","text":"<ul> <li>Pros: They do not require a trusted setup, which is a massive security benefit. They rely on more common cryptographic assumptions.</li> <li>Cons: They are less efficient than KZG. The proof size and verification time grow logarithmically with the size of the polynomial, which is still very fast but not constant.</li> </ul>"},{"location":"pcs/#comparing","title":"Comparing","text":"Scheme Name Proof Size Verification Time Prover Time Trusted Setup Security Assumption Core Technique Advantages Disadvantages KZG <sup>1</sup> Constant Constant \\(O(n \\log n)\\) Required (Universal Setup) Discrete Log on Pairing-friendly curves Bilinear Pairings Small proofs, fast verification Relies on a trusted setup Bulletproofs <sup>2</sup> \\(O(\\log^2 n)\\) \\(O(\\log n)\\) \\(O(n \\log n)\\) Not required Discrete Logarithm (DL) problem Inner Product Argument No trusted setup, small proof size Slower verification than KZG FRI <sup>3</sup> \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(n \\log n)\\) Not required Collision resistance of hash functions Iterative low-degree testing Fully transparent, post-quantum secure Relatively large proofs, high verification cost IPA <sup>4</sup> \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(n \\log n)\\) Not required Discrete Logarithm (DL) problem Inner Product Argument, Fiat-Shamir No trusted setup, logarithmic proof size Can be slower than KZG for large n Hyrax <sup>5</sup> \\(O(\\log n)\\) \\(O(\\log^2 n)\\) \\(O(n \\log n)\\) Not required DL and Strong RSA assumptions Vector commitments, inner product arguments No trusted setup, fast verification Relies on specific assumptions Brakedown <sup>6</sup> Constant \\(O(n)\\) \\(O(n \\log n)\\) Not required DL and higher-order DL assumptions Batching techniques Constant-size proofs without trusted setup Linear verification time Gemini <sup>7</sup> Constant \\(O(\\log n)\\) \\(O(n \\log n)\\) Not required DL and higher-order DL assumptions Polynomial combination for batching Combines KZG and FRI advantages Relatively complex protocol Virgo <sup>8</sup> \\(O(\\log^2 n)\\) \\(O(\\log^2 n)\\) \\(O(n \\log n)\\) Not required Polylogarithmic inner product argument Vector polynomial delegation No trusted setup, post-quantum secure Proof and verification time are not constant"},{"location":"pcs/#key-metrics-explained","title":"Key Metrics Explained","text":"<ul> <li>Proof Size: A smaller proof size reduces network transmission overhead, which is crucial in scenarios like blockchains. KZG and Dark/Brakdown achieve the ideal constant-size proofs, while FRI and Virgo achieve logarithmic or polylogarithmic growth, which is significantly better than linear.</li> <li>Verification Time: This is a critical metric for on-chain verification. KZG has the fastest, constant-time verification. Bulletproofs, FRI, and Gemini also have very fast logarithmic verification times, while Dark and Virgo are slightly slower.</li> <li>Prover Time: The prover time for all major schemes is quasi-linear, at \\(O(n \\log n)\\), so there is little significant difference in this metric.</li> <li>Trusted Setup: Whether a scheme requires a trusted setup is a key differentiator. KZG requires a one-time, universal trusted setup, and if this process is compromised, the entire system's security can be at risk. Schemes like FRI, Bulletproofs, Hyrax, and Virgo are transparent and do not require a trusted setup, giving them a natural security advantage.</li> <li>Security Assumptions: Different schemes rely on different mathematical problems. KZG depends on the difficulty of problems on bilinear pairings. FRI and Virgo primarily rely on the collision resistance of hash functions, making them generally considered post-quantum secure.</li> </ul>"},{"location":"pcs/#references","title":"References","text":"<ol> <li> <p>Kate, A., Zaverucha, G., &amp; Goldberg, I. (2010). Constant-size commitments to polynomials and their applications.\u00a0\u21a9</p> </li> <li> <p>B\u00fcnz, M., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., &amp; Maxwell, G. (2018). Bulletproofs: Short proofs for confidential transactions and more.\u00a0\u21a9</p> </li> <li> <p>Ben-Sasson, E., Bentov, I., Horesh, Y., &amp; Riabzev, M. (2018). Scalable, transparent, and post-quantum secure computational integrity.\u00a0\u21a9</p> </li> <li> <p>Groth, J. (2016). On the size of pairing-based non-interactive arguments.\u00a0\u21a9</p> </li> <li> <p>Wahby, R. S., Tzialla, I., Shelat, A., Thaler, J., &amp; Walfish, M. (2017). Doubly-efficient zkSNARKs without trusted setup.\u00a0\u21a9</p> </li> <li> <p>Golovnev, A., Lee, J., Setty, S., Thaler, J. &amp; Wahby, R. S. (2021). Brakedown: Linear-time and field-agnostic SNARKs for R1CS.\u00a0\u21a9</p> </li> <li> <p>Bootle, J., Chiesa, A., Hu, Y., &amp; Orr\u00f9, M. (2022). Gemini: Elastic SNARKs for Diverse Environments.\u00a0\u21a9</p> </li> <li> <p>Zhang, J., Xie, T., Zhang, Y., &amp; Song, D. (2020). Virgo: Transparent polynomial delegation and its applications to zero-knowledge proof.\u00a0\u21a9</p> </li> </ol>"},{"location":"pcs/ipa/","title":"IPA Commitment","text":""},{"location":"pcs/kzg/","title":"KZG Commitment","text":""},{"location":"pcs/kzg/#preliminaries","title":"Preliminaries","text":"<ol> <li> <p>A \"Toxic Waste\" Trusted Setup: This is the most controversial part of KZG. A one-time setup ceremony is required to generate a set of public parameters, known as the Structured Reference String (SRS). A trusted party (or, more commonly, a multiparty computation or MPC) generates a random secret number, say \\(\\tau\\), and then computes a set of points on an elliptic curve corresponding to the powers of \\(\\tau\\), without ever revealing \\(\\tau\\) itself. These points are made public, and the secret \\(\\tau\\) is \"ceremonially destroyed\" (hence, \"toxic waste\"). As long as at least one participant in the MPC ceremony was honest and deleted their share of the secret, the security of the entire system holds.</p> </li> <li> <p>Elliptic Curve Pairings: This is the mathematical engine of KZG. A bilinear pairing is a special function, let's call it \\(e\\), that takes two points on an elliptic curve and maps them to a third group. The key property is that it allows for a form of multiplication across different groups. Formally, for a pairing-friendly elliptic curve, the pairing \\(e(P, Q)\\) has the property that \\(e(aP, bQ) = e(P, Q)^{ab}\\), where \\(P, Q\\) are points on the curve and \\(a, b\\) are scalars. This is the cryptographic primitive that allows for verification without revealing the secret \\(\\tau\\).</p> </li> </ol>"},{"location":"pcs/kzg/#kzg-commitment-for-univariant-polynomial","title":"KZG Commitment for Univariant Polynomial","text":"<p>The process of a KZG commitment can be broken down into four distinct phases:</p>"},{"location":"pcs/kzg/#1-trusted-setup","title":"1. Trusted Setup","text":"<p>As mentioned, this is a one-time ceremony that generates the public parameters (the SRS) which are then used by everyone. The SRS consists of points on a pairing-friendly elliptic curve, such as \\([1]_\\mathbb{G_1}, [\\tau]_\\mathbb{G_1}, [\\tau^2]_\\mathbb{G_1}, \\dots, [\\tau^d]_\\mathbb{G_1}\\) where \\(d\\) is the maximum degree of any polynomial to be committed to, and \\([x]_\\mathbb{G_1}\\) denotes the point \\(x \\cdot G_1\\), with \\(G_1\\) being the generator of the group.</p>"},{"location":"pcs/kzg/#2-commitment","title":"2. Commitment","text":"<p>The prover, who has a polynomial \\(P(x)\\) of degree at most \\(d\\), wants to commit to it. They compute the commitment \\(C\\) by \"evaluating\" the polynomial at the secret point \\(\\tau\\) in the exponent. Since they don't know \\(\\tau\\), they use the public SRS:</p> <p>\\(C = [P(\\tau)]_{\\mathbb{G_1}} = [\\sum_{i=0}^d p_i \\tau^i]_{\\mathbb{G_1}} = \\sum_{i=0}^d p_i [\\tau^i]_{\\mathbb{G_1}}\\)</p> <p>The result, \\(C\\), is a single point on the elliptic curve\u2014a constant-sized commitment regardless of the polynomial's degree. The prover sends this commitment to the verifier. Because of the cryptographic properties, the commitment is binding: once the prover has generated \\(C\\), they cannot \"open\" it to a different polynomial.</p>"},{"location":"pcs/kzg/#3-proving-an-evaluation","title":"3. Proving an Evaluation","text":"<p>Now, the prover wants to convince the verifier that the polynomial \\(P(x)\\) evaluates to a specific value \\(y\\) at a point \\(a\\). That is, they want to prove \\(P(a) = y\\).</p> <p>The prover constructs a new polynomial, the \"quotient polynomial\" \\(Q(x)\\):</p> <p>\\(Q(x) = \\frac{P(x) - y}{x - a}\\)</p> <p>The key insight here is from the Remainder Theorem in algebra: \\(P(a) - y = 0\\) if and only if \\((x-a)\\) is a factor of \\(P(x) - y\\). If the evaluation is correct (\\(P(a) = y\\)), then \\(Q(x)\\) will be a valid polynomial. The prover then computes a commitment to this quotient polynomial, which will serve as the proof \\(\\pi\\):</p> <p>\\(\\pi = [Q(\\tau)]_{\\mathbb{G_1}}\\)</p> <p>The prover sends the claimed evaluation \\((a, y)\\) and the proof \\(\\pi\\) to the verifier.</p>"},{"location":"pcs/kzg/#4-verification","title":"4. Verification","text":"<p>The verifier receives the commitment \\(C\\), the claimed evaluation \\((a, y)\\), and the proof \\(\\pi\\). They want to check if the equation \\(P(x) - y = (x-a)Q(x)\\) holds at the secret point \\(\\tau\\). Using the bilinear pairing, they can check this equality in the exponent without ever knowing \\(\\tau\\).</p> <p>The verifier checks if the following pairing equation holds:</p> <p>\\(e(\\pi, [\\tau - a]_{\\mathbb{G_2}}) = e(C - [y]_{\\mathbb{G_1}}, G_2)\\)</p> <p>Let's unpack this with the pairing property: -   Left side: \\(e(\\pi, [\\tau - a]_{\\mathbb{G_2}}) = e([Q(\\tau)]_{\\mathbb{G_1}}, [\\tau - a]_{\\mathbb{G_2}}) = e(G_1, G_2)^{Q(\\tau)(\\tau-a)}\\) -   Right side: \\(e(C - [y]_{\\mathbb{G_1}}, G_2) = e([P(\\tau)]_{\\mathbb{G_1}} - [y]_{\\mathbb{G_1}}, G_2) = e([P(\\tau)-y]_{\\mathbb{G_1}}, G_2) = e(G_1, G_2)^{P(\\tau)-y}\\)</p> <p>The equation holds if and only if \\(P(\\tau) - y = Q(\\tau)(\\tau - a)\\), which, because of the Schwartz-Zippel Lemma, proves with a high probability that \\(P(x) - y = (x-a)Q(x)\\) and therefore that \\(P(a) = y\\).</p> <p>The proof is verified, and the verifier is convinced the prover's claim is correct, all with constant-sized data and a small amount of computation.</p>"}]}