{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Welcome to zkSNARK wiki","text":""},{"location":"contri/","title":"zkSNARK Wiki: Contribution Guide","text":""},{"location":"contri/#getting-started","title":"Getting Started","text":"<ol> <li>Clone the repository: <code>git clone https://github.com/zksnark-wiki/zksnark-wiki.github.io.git</code></li> <li>Install MkDocs: <code>pip install mkdocs</code></li> <li>Install the Material for MkDocs theme: <code>pip install mkdocs-material</code></li> </ol>"},{"location":"contri/#workflow","title":"Workflow","text":"<ol> <li>Remember to pull and merge.</li> <li>Create a new Markdown (<code>.md</code>) file in the <code>docs</code> directory and write your content.</li> <li>Integrate your new page into the navigation by editing <code>mkdocs.yml</code></li> <li>Preview your changes locally with <code>mkdocs serve</code>.</li> <li>Commit your updates to Git:<ul> <li><code>git add .</code></li> <li><code>git commit -m \"Add new post about X\"</code></li> <li><code>git push</code></li> </ul> </li> <li>Deploy the site to GitHub Pages: <code>mkdocs gh-deploy --force</code></li> </ol>"},{"location":"commitment/","title":"Commitment","text":"<p>Commitment</p>"},{"location":"commitment/pedersen/","title":"Pedersen Commitment","text":"<p>Pedersen Commitment can be derived from Schnorr's \\(\\Sigma\\)-protocol for the Discrete Logarithm Relation.</p> <p>At the start of the protocol, the prover generates two generators of the group \\(\\mathbb G\\), we denote them with \\(g, h\\). To commit to \\(m\\in\\mathbb Z_q\\), the prover chooses \\(z\\in\\mathbb Z_q\\) randomly and sends \\(C_m=g^m\\cdot h^z\\) to the verifier. To open it, the prover just sends \\((m,z)\\) to the verifier, and verifier checks that \\(C_m\\stackrel{?}{=}g^m\\cdot h^z\\).</p> <p>The correctness, computational binding and perfect hiding is directly guarenteed by the properties of \\(\\Sigma\\)-protocol and Damg\u00e5rd's construction.</p> <p>Moreover, Pedersen Commitment is additively homomorphic.</p>"},{"location":"commitment/pedersen/#establishing-product-relationship","title":"Establishing Product Relationship","text":""},{"location":"commitment/pedersen/#pedersen-vector-commitment","title":"Pedersen Vector Commitment","text":"<p>\\(C_m=g_0^{m_0}g_1^{m_1}\\cdots g_{n-1}^{m_{n-1}}h^{z}\\)</p>"},{"location":"pcs/","title":"Polynomial Commitment Scheme","text":""},{"location":"pcs/#what-are-polynomial-commitment-schemes-pcs","title":"What Are Polynomial Commitment Schemes (PCS)?","text":"<p>Imagine you're a magician who wants to prove you know a secret polynomial\u2014a long, complicated mathematical equation\u2014without revealing what it is. You want to convince someone that your polynomial, when evaluated at a specific number, equals a certain value. But there's a catch: you can only send them a tiny, fixed-size proof.</p> <p>This is the essence of a Polynomial Commitment Scheme (PCS). It's a cryptographic primitive that lets a prover \"commit\" to a polynomial in a way that is both succinct and secure.</p> <p>In simpler terms, a PCS is a powerful tool with three main steps:</p> <ol> <li>Commit: You take a polynomial, \\(P(x)\\), and generate a short, cryptographic representation of it. This is the commitment. Think of it as a fingerprint for the polynomial. You can share this fingerprint with anyone without revealing the polynomial's coefficients.</li> <li>Open: Later, someone gives you a challenge: \"What's the value of your polynomial at point \\(z\\)?\" You respond with the value, \\(v = P(z)\\), and a very small proof \\(\\pi\\).</li> <li>Verify: The verifier uses your original commitment, the point \\(z\\), the claimed value \\(v\\), and your proof \\(\\pi\\) to check if everything is correct. The amazing part? They can do this in a fraction of a second, without ever seeing the polynomial itself.</li> </ol>"},{"location":"pcs/#what-makes-a-good-pcs","title":"What Makes a Good PCS?","text":"<p>Not all schemes are created equal. A high-quality PCS should have these properties:</p> <ul> <li>Succinctness: The commitment and the proof must be extremely small, regardless of how large the polynomial is. This is what makes it practical.</li> <li>Binding: Once you commit to a polynomial, you can't change your mind. It's impossible to \"open\" the commitment to a different polynomial.</li> <li>Hiding: The commitment should not reveal any information about the polynomial's coefficients.</li> </ul>"},{"location":"pcs/#univariant-and-multilinear","title":"Univariant and Multilinear","text":"<p>Polynomials come in different forms, and PCS are often classified by the type they are designed for. For most use cases, we need either a univariant PCS or a multilinear PCS.</p> <ul> <li> <p>Univariant Polynomials: These are the polynomials involving only a single variable, like \\(P(x) = 5x^3 + 2x - 1\\). Many popular schemes, including KZG, are designed for these single-variable polynomials.</p> </li> <li> <p>Multilinear Polynomials: A multilinear polynomial is a special type of polynomial with multiple variables, where each variable appears with a power of at most 1. They are often used to represent logical circuits or computations. Schemes like the FRI are designed to handle these types of polynomials efficiently.</p> </li> </ul>"},{"location":"pcs/#popular-pcs-examples","title":"Popular PCS Examples","text":"<p>There are a few widely-used PCS, each with its own trade-offs. The main difference often comes down to their efficiency and whether they need a trusted setup. A trusted setup is a one-time cryptographic event that generates public parameters. If this event is compromised, the entire system's security can be at risk.</p>"},{"location":"pcs/#kzg-kate-zaverucha-goldberg-commitments","title":"KZG (Kate-Zaverucha-Goldberg) Commitments","text":"<ul> <li>Pros: They are incredibly efficient. Both the proof size and the verification time are constant, meaning they stay the same no matter how large the polynomial is.</li> <li>Cons: They require a trusted setup. This has led to high-profile ceremonies like the one for the Zcash network, where many people participate to ensure no single party holds the secret.</li> </ul>"},{"location":"pcs/#ipa-inner-product-argument-commitments","title":"IPA (Inner Product Argument) Commitments","text":"<ul> <li>Pros: They do not require a trusted setup, which is a massive security benefit. They rely on more common cryptographic assumptions.</li> <li>Cons: They are less efficient than KZG. The proof size and verification time grow logarithmically with the size of the polynomial, which is still very fast but not constant.</li> </ul>"},{"location":"pcs/ipa/","title":"IPA Commitment","text":""},{"location":"pcs/kzg/","title":"KZG Commitment","text":""},{"location":"pcs/kzg/#univariant-version","title":"Univariant Version","text":""},{"location":"pcs/kzg/#multivariant-version","title":"Multivariant Version","text":""}]}